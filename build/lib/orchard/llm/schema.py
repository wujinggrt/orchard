from enum import Enum
from typing import Literal
from pydantic import BaseModel, Field


class Role(str, Enum):
    """Message role options"""

    SYSTEM = "system"
    USER = "user"
    ASSISTANT = "assistant"
    TOOL = "tool"


ROLE_VALUES = tuple(role.value for role in Role)
ROLE_TYPE = Literal[ROLE_VALUES]  # type: ignore


class Function(BaseModel):
    arguments: str
    """
    The arguments to call the function with, as generated by the model in JSON
    format. Note that the model does not always generate valid JSON, and may
    hallucinate parameters not defined by your function schema. Validate the
    arguments in your code before calling your function.
    """

    name: str
    """The name of the function to call."""


class ToolCall(BaseModel):
    """Represents a tool/function call in message"""

    id: str
    function: Function
    type: Literal["function"]
    """The type of the tool. Currently, only `function` is supported."""


class Message(BaseModel):
    """Represents a chat message in the conversation."""

    role: ROLE_TYPE = Field(...)  # type: ignore
    content: str | None = Field(default=None)
    tool_calls: list[ToolCall] | None = Field(default=None)
    """在 assistant message 中提供作用。"""
    name: str | None = Field(default=None)  # 对话者的名字
    tool_call_id: str | None = Field(default=None)
    base64_image: str | None = Field(default=None)

    def to_dict(self) -> dict:
        """Convert message to dictionary format"""
        message = {"role": self.role}
        if self.content is not None:
            message["content"] = self.content
        if self.tool_calls is not None:
            message["tool_calls"] = [
                tool_call.model_dump() for tool_call in self.tool_calls
            ]
        if self.name is not None:
            message["name"] = self.name
        if self.tool_call_id is not None:
            message["tool_call_id"] = self.tool_call_id
        if self.base64_image is not None:
            message["base64_image"] = self.base64_image
        return message

    @classmethod
    def user_message(
        cls, *, content: str, base64_image: str | None = None
    ) -> "Message":
        """Create a user message"""
        return cls(role=Role.USER, content=content, base64_image=base64_image)

    @classmethod
    def system_message(cls, *, content: str) -> "Message":
        """Create a system message"""
        return cls(role=Role.SYSTEM, content=content)

    @classmethod
    def assistant_message(
        cls, *, content: str | None = None, base64_image: str | None = None
    ) -> "Message":
        """Create an assistant message"""
        return cls(role=Role.ASSISTANT, content=content, base64_image=base64_image)

    @classmethod
    def tool_message(
        cls,
        *,
        content: str,
        name,
        tool_call_id: str,
        base64_image: str | None = None,
    ) -> "Message":
        """Create a tool message"""
        return cls(
            role=Role.TOOL,
            content=content,
            name=name,
            tool_call_id=tool_call_id,
            base64_image=base64_image,
        )

    @classmethod
    def from_tool_calls(
        cls,
        *,
        tool_calls: list[ToolCall],
        content: str | None = "",
        base64_image: str | None = None,
        **kwargs,
    ):
        """Create ToolCallsMessage from raw tool calls.

        Args:
            tool_calls: Raw tool calls from LLM
            content: Optional message content
            base64_image: Optional base64 encoded image
        """
        # formatted_calls = [
        #     {"id": call.id, "function": call.function.model_dump(), "type": "function"}
        #     for call in tool_calls
        # ]
        return cls(
            role=Role.ASSISTANT,
            content=content,
            tool_calls=tool_calls,
            base64_image=base64_image,
            **kwargs,
        )


class Memory(BaseModel):
    messages: list[Message] = Field(default_factory=list)
    max_messages: int = Field(default=100)

    def add_message(self, *, message: Message) -> None:
        """Add a message to memory"""
        self.messages.append(message)
        # Optional: Implement message limit
        if len(self.messages) > self.max_messages:
            self.messages = self.messages[-self.max_messages :]

    def add_messages(self, *, messages: list[Message]) -> None:
        """Add multiple messages to memory"""
        self.messages.extend(messages)

    def clear(self) -> None:
        """Clear all messages"""
        self.messages.clear()

    def get_recent_messages(self, *, n: int) -> list[Message]:
        """Get n most recent messages"""
        return self.messages[-n:]

    def to_dict_list(self) -> list[dict]:
        """Convert messages to list of dicts"""
        return [msg.to_dict() for msg in self.messages]
